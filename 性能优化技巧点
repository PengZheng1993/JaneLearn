性能优化技巧点-量级优化
1. 日志优化 不要打同步磁盘日志，不要打info日志
2. 序列化优化，不要使用json.toJSONString()方法进行序列化，可以自行转换填充需要的字段，不然会有大对象产生
3. 不要使用java8流式编程，对于大容器，复杂逻辑，尽量不要使用流式编程
4. 尽量使用LinkedList提高内存利用率，减少内存碎片
5. 批量查询(tair，数据库等)减少网络通信量
6. 代码预热，应用启动初期jvm都是解释执行，待热点代码出现将自动编译，提高执行速度。同时缓存的热点数据要进行载入和替换。
核心还是减少内存使用，避免对象频繁创建回收，减少gc次数，减少与磁盘交互，减少网络开销。

性能优化技巧点-日常编码习惯
线程
1. 尽量使用线程池减少线程开销
2. 同步代码粗化，减少循环调用等重复的锁开销。
3. 同步代码细化，同步竞争，应尽量减小同步范围。2主要减少同步调用次数，3主要减少竞争范围
4. 使用线程安全的类，使用juc中的组件，比自己写性能高且简洁
5. 在单线程中，或者不会发生竞争中的类，不要使用线程安全的类，避免不必要的锁开销
缓冲区
6. 尽量使用缓冲流减少IO操作
7. 尽量使用同一缓存区，避免缓冲区的重复申请和释放
8. 初始化时尽量指定缓冲区大小，避免扩容浪费时空资源
异常
9. 禁止使用异常控制业务流程, 使用条件表达式先判断出现异常的条件
10. 尽量避免在循环中捕获异常
11. 直接捕获异常，避免用instanceof判断
字符串
12. 避免先判断存在再进行获取，比如先判断contains再get，可以直接对get的结果判空
13. 尽量使用hashSet判断是否存在
14. 对于非随机访问容器，使用迭代而非随机访问，如：for(T t : List<T>)而不是 for(int i = 0; i<Size; i++) list.get(i)
15. 直接迭代需要使用的集合
16. 尽量使用Arrays.asList转化数组
17. 不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合
18. 初始化集合时，尽量指定集合大小
19. 集合转化为Object数组时，尽量使用toArray()方法
20. 尽量预编译正则表达式 Pattern.compile的性能开销，该方法隐藏在matches replace split等方法中，将正则编译提出来预先执行，重复利用
21. 使用String.valueOf(i)，不要用""+
22. 使用StringBuilder
23. 使用字符替换字符串, indexOf(',')，replace('1','2')
24. 尽量不要使用正则表达式

方法
25. 多使用switch进行跳转优化，而不用if进行逻辑判断
26. 尽量不要使用取反
27. 提取公共表达式
28. 使用移位代替正整数整除
29. 尽量避免不必要的方法调用
30. 尽量减少方法的重复调用  for(i;i<list.size();i++)将长度提取出来预先定义
31. 尽量使用方法传递代替值传递
32. 尽量使用方法传递代替值传递，值传递过程要经过复制，使用方法或者引用复制指针，
33. 尽量指定方法的final修饰符, java编译器会内联所有final方法，评价提升50%的性能
34. 尽量避免不必要的函数封装，方法调用入栈和出栈，消耗cpu和内存
35. API支持判空，则不要再判空
35. 方法一律返回非空，避免空判断
36. 协议参数值非空，避免不必要的空指针判断
37. 尽量使用基本数据类型，避免装拆箱和空指针判断
38. 把跟类成员变量无关的方法声明成静态方法
对象&类
39. 尽量指定类final修饰符 
40. 避免定义不必要的子类
41. 使用lambda表达式代替内部匿名类(lambda表达式虚拟机采用invokeDynamic指定实现)
42. 尽量不要使用反射赋值对象.
43. 禁止使用JSON转化对象(性能是问题，建议自己写转化工具)，除非有序列化和反序列化需求
常量&变量
44. 不可变的成员变量，尽量使用非线程安全类, 不变量不需要走同步，避免开销
45. 尽量不要再循环体外定义变量。与循环体外定义变量运行效率一样，但是可以减少变量声明周期，减少开销
46. 尽量使用函数内的基本类型临时变量，基本类型临时变量都在栈上访问速度快
47. 如果变量的初值会被覆盖，就没有必要给变量赋初值
48. 尽量使用基本数据类型，避免自动装拆箱
49. 成员变量值无需改变时，尽量定义为静态常量
50. 直接赋值常量值，禁止声明新对象, 赋值常量值只是创建一个引用，声明新对象会创建对象。



